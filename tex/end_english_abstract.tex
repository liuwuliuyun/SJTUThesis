%# -*- coding: utf-8-unix -*-
\begin{bigabstract}
	
Fuzzy search is a type of search method that searches for the same or similar data. This paper focuses on the fuzzy search of large-scale face data, from the aspects of face detection, feature extraction and vector matching, and finally implements a complete imperceptible face recognition system.

Imperceptible face recognition system is a face recognition system which does not require intentional cooperation from users. This system can be widely used for student attendance management and access control in companies because it requires less human resources and is time-efficient. 

This system pulls live images of faces from CCTV or embedded devices at first. Then images are sent to GPU server at where face detection, face counting and face recognition programs run. After that, face embeddings extracted by face recognition module are sent to vector matching module which performs nearest neighbor search. Recognition module also connects each face embedding with an identity. Finally, deliver module sends identities required back to user.

The research work is mainly divided into four phases. The main research contents and achievements of each phase are as follows:

The first phase is to establish CFDDB dataset. Before choosing the right face detection and recognition algorithm, we should choose or build a benchmark which is suited for imperceptible face recognition. In the area of face detection, there have been a large number of public data sets for training and testing. Commonly used are WIDER FACE\cite{yang2016wider}, FDDB\cite{fddbTech}, LFW\cite{huang2007labeled} and so on. However, the faces in these data sets are mostly European and American, and the number of faces in each photo is also limited. The images extracted from the surveillance videos are mostly Asian, and the faces are often blurred, angled, or occluded. Therefore, the existing test set cannot meet our test requirements. According to this, we have established our own test set CFDDB (Classroom Face Detection Database).

The test set images were generated by capturing one frame every 100 frames from a 15-minute surveillance video and has 149 images. After preprocessing, there were 134 images available in the test set, with 1,087 faces and a total of 84 people. Analysis of the 7 images taken in the sample shows that the angled face images in CFDDB are more than $70\%$ and occluded faces are about $58\%$. These features make the CFDDB test set a great challenge for any face detection algorithm and recognition algorithm.

There are five parts in the second phase. First, we encapsulate the cascading classifier \cite{viola2004robust} based on the HAAR feature, implement a CFDDB-based test interface, and analyze its performance based on recall rate and time efficiency. Second, MtCNN\cite{zhang2016joint} is packaged, accelerated using a GPU server, and its performance is analyzed based on its network structure and functionality. Third, test the SSH detector \cite{najibi2017ssh}, implement a CFDDB-based test interface, and perform parameter tuning. Fourth, test the Tiny face detector \cite{hu2017finding}, implement the CFDDB-based test interface, and compare the results after the SSH detector is tuned. Fifth, test the high-precision face recognition algorithm InsightFace\cite{deng2018arcface} to ensure that it has a high recall rate on CFDDB.

After completing this phase of work, we have achieved the following three points of research results. First, the HAAR cascade classifier and MtCNN recall rate are too low to meet the requirements. Second, Tiny face detectors are not time-efficient. Finally, even without considering the time efficiency, the SSH detector is still better than the Tiny face detector when considering the recall rate and the misjudgment rate comprehensively. Therefore, the SSH detector is selected as the core algorithm of the face detection module.

The main content of the next phase is the design and optimization of face embedding matching algorithms. First, the matching algorithm for small-scale datasets is designed and analyzed based on its time efficiency and space efficiency. Second, matching algorithms for large-scale data sets are designed and we provide some optimization strategies for them.

We have four requirements for a qualified face embedding matching algorithm:

The first is accuracy. The result of a query should be very close to the result of a linear search. The second is fast. The time complexity of the algorithm should not be more complicated than $O(n)$. The third is high efficiency, that is, ideally, the index of data should be linear to the size of dataset. The fourth is high dimension. Since the dimensions of face embedding vectors are often more than 100, the algorithm needs to support efficient search for high-dimensional features.

In addition to linear search, search algorithms are usually based on tree-structured algorithms such as R-tree and KD tree. However, when the dimension exceeds 10, the time efficiency of these precise algorithms has exceeded linear search\cite{weber1998quantitative}. Since the dimension of the face embedding vector is basically at the level of 100. Using these exact search algorithms cannot meet the high-dimensional requirements, these algorithms are not suitable for the system's matching algorithm.

In the field of machine learning, support vector machines (SVMs) are often used for the classification and regression of high-dimensional vectors. In the matching phase of face embeddings, if there are $n$ embedding vectors in the face feature database, then we use SVM to find the embedding vector matched by the query vector $\mathbf{q}$ in two ways:

The first way is to train $n$ classifiers. Each classifier distinguishes one embedding vector in the face feature database from all remaining embedding vectors. In use, each classifier is required to classify the query vector $\mathbf{q}$. If $\mathbf{q}$ is in the same class with a embedding vector, then the embedding vector is marked as $\mathbf{q}$ matching candidates.

The second way is to train $C_n^2$ classifiers to distinguish any randomly selected pair of embedding vectors from the $n$ embedding vector database. When we need to find a match for the query vector $\mathbf{q}$, we use each trained classifier to classify $\mathbf{q}$, each time adding the weight of the embedding vector category represented by the output of the classifier. When all the classifiers have been classified, the embedding vector in the class with the highest weight is selected as the matching result.

These two ideas are feasible when database size is not large. In some simple face recognition systems, it is very common to use multi-class SVMs to match high-dimensional face embedding vectors.

We notice that face embedding vectors have following feature. Faces with the same identities will generate embedding vectors with closer distances, while faces with different identities will often produce embedding vectors with relatively long distances. Thus, the matching process of the face embedding vector can be equated to finding the nearest neighbor to the query vector $\mathbf{q}$. Through this transformation, we will match the problem to the nearest neighbor search problem.

LSH-based approximate search algorithm or directed-graph based algorithm to match large-scale data. At the same time, the optimization method of LSH-based approximate search algorithm is discussed.

The final phase is system architecture design. The architecture design of the non-perceived face recognition system is mainly divided into three parts: data processing flow, device network topology and system logic architecture. Among them, the data processing flow mainly describes the data storage structure, data format and data flow in the system. The device network topology mainly describes the physical deployment features and network topology of all the machines in the system. The system logic architecture mainly describes all the modules and components in the system, as well as the interaction and function assignment between different module components.

The first to enter the system is the video stream data acquired by the camera and the embedded device. This part of the data is uploaded to the image queue after the frame is locally intercepted. The image queue is a priority queue maintained by the server. Its length is determined based on the system's requirements and the server's performance. Whenever a new image is received, first check if the queue is full. If the queue is full, the image is discarded and the server is sent a busy message back to user. If the queue is not full, the image is inserted into the queue according to the priority of the image. Each image in the queue should have a unique tag to indicate the source of the image.

When face detection is performed, an image is taken from the front of the image queue for detection each time. After the detection is completed, the obtained face region is marked and put into the face queue according to the image tag. If the face queue is full, the marked face area is stored in a specific area in the server. When there are free positions in the face queue, the stored content is read from the hard disk and added to the tail of the face queue, and the corresponding content in the hard disk is deleted.

When face recognition is performed, batch-sized face images and their tags are loaded from the front end of the face queue into the face recognition module to obtain batch size feature vectors and tags. These feature vectors and their tags are then sent to the face database for matching. 

Finally, according to the tag of each piece of identity information, all identity information requested by a certain user is returned to the user.

There are two implementations of the image acquisition module, one deployed to the box that connects the camera devices and the other to the embedded device. 

Through the comparison of the second phase, the SSH detector\cite{najibi2017ssh} is face detector that meets our system's face detection requirements. The memory space needed for each SSH detector needs to be considered during deployment to maximize the utilization of resources in the GPU server. 

InsightFace\cite{deng2018arcface} is packaged as a face recognition module. A good system design is to use the same Docker container for the face detection module and the face recognition module. The external program then uses the GRPC framework to call the internal program of the container to perform detection and recognition.

If the algorithm for face detection or face recognition uses TensorFlow as framework, TFserving can be used for encapsulation which make algorithm update and model management easier.

In the end, we implement the non-perceived face recognition system and keep it highly efficient, stable, and scalable.


\end{bigabstract}